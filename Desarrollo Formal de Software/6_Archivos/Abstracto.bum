<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.configuration="org.eventb.core.fwd;de.prob.units.mchBase;org.eventb.codegen.ui.cgConfig" org.eventb.texttools.text_lastmodified="1535647018386" org.eventb.texttools.text_representation="machine Abstracto sees Contexto_1&#10;variables fsist // el sistema de archivos&#10;          usuarios archivos&#10;&#10;invariants&#10;  @inv1 usuarios ⊆ USRS&#10;  @inv2 archivos ⊆  ARCH&#10;  @inv3 fsist ∈ archivos → (usuarios ↔ PERM)&#10;  /* Incluir invariante @inv4&#10;     En el modelo se especifica que cada archivo tiene una unica relacion de usuarios con permisos, de modo que para cada uno de&#10;     los archivos se tiene una tabla donde se relacionan cada usuario con los permisos que tiene. por ejemplo&#10;     {(archivo1 -&gt; {(juanito-&gt; leer),(juanito-&gt;escribir),(juanito-&gt;borrar),(juanito-&gt;ejecutar),(pepito-&gt;escribir)}} */&#10;  @inv4 ∀a · a∈ran(fsist) ⇒ (∃u·u∈dom(a) ∧ a[{u}] = PERM)&#10;  /* la invariante dice que para todos los archivos debe existir almenos un&#10;     usuario que tenga todos los permisos de PERM.&#10;     Integrantes Nicolas Ortiz y Ivan Valderrama&#10;     Requerimiento de prueba:&#10;     - Quitar/inv4[∃ u .u∈dom(a0) ∧ a0[{u}]=PERM]:  Pide que pruebe que despues de quitar un permiso se cumple la invariante que&#10;     siga habiendo un usuario con todos los permisos. Es una prueba inmediata debido a que esta explicito en la guarda (grd4).&#10;     - Otorgar/inv4[∃ u ·u∈dom(a0) ∧ a0[{u}]=PERM]: Pide que pruebe que despues de otorgar un permiso se cumple la invariante que&#10;     siga habiendo un usuario con todos los permisos. Es una prueba inmediata debido a que se esta agregando un permiso, no quitando.&#10;     - Crear/inv4[∃ u ·u∈dom(a0) ∧ a0[{u}]=PERM]: Pide que pruebe que el archivo nuevo que va a crear cumple la condicion de la invariante 4.&#10;     Es inmediato debido a que el evento le agrega inicialemnte al alchivo a cada uno de sus creadores todos los permisos del archivo.&#10;     -Quitar/inv3[￼&#9;fsist{a ↦ fsist(a) ∖ ({u} × prs)}∈archivos → (usuarios ↔ PERM)]: Pide que pruebe que al elmiminar los permisos del usuario sigue perteneciendo a fsist, lo cual es inmediato por las guardas. */&#10;events&#10;event INITIALISATION&#10;    then&#10;      @act1 usuarios ≔  ∅&#10;      @act2 archivos ≔ ∅&#10;      @act3 fsist ≔  ∅&#10;  end&#10;&#10;  event nuevo&#10;    any u&#10;    where&#10;      @grd1 u ∈ USRS∖usuarios&#10;    then&#10;      @act1 usuarios ≔ usuarios ∪  {u}&#10;  end&#10;&#10;  event crear&#10;    any a gente&#10;    where&#10;      @grd1 a ∈ ARCH∖archivos&#10;      @grd2 gente ⊆  usuarios&#10;      @grd3 gente ≠ ∅&#10;    then&#10;      @act1 archivos ≔ archivos  ∪  {a}&#10;      @act2 fsist(a) ≔ gente × PERM&#10;  end&#10;&#10;  event otorgar&#10;    any p u a&#10;    where&#10;      @grd1 p ∈ PERM&#10;      @grd2 u ∈ usuarios&#10;      @grd3 a ∈ archivos&#10;      @grd4 u↦p ∉ fsist(a)&#10;    then&#10;      @act1 fsist(a) ≔ fsist(a) ∪ {u↦p}&#10;  end&#10;&#10;  event quitar&#10;    any prs u a&#10;    where&#10;      @grd0 a ∈ archivos&#10;      @grd1 u ∈ dom(fsist(a))&#10;      @grd2 prs ⊆ fsist(a)[{u}] // {u} x prs ⊆ fsist(a)&#10;      @grd3 prs≠∅&#10;      @grd4 (fsist(a)[{u}]=PERM) ⇒ (∃x· x∈dom(fsist(a)) ∧(fsist(a)[{x}]=PERM) ∧ x≠u)//∃x· x∈dom(fsist(a)∧ x ≠ u ∧ fsist(a)[{otro}] = PERM&#10;      /* Se garantiza que la persona a la&#10;         que se le van a restringir los permisos no sea la unica  persona que tenga todos los permisos */&#10;    then&#10;      @act1 fsist(a) ≔ fsist(a)∖ ({u}×prs) // Se sustrae a la tabla del archivo a las parejas que tengan de usuario u.&#10;  end&#10;end&#10;" version="5">
<org.eventb.core.seesContext name="_pAvDwKxsEeiUDoNOpRQlQA" org.eventb.core.target="Contexto_1"/>
<org.eventb.core.event name="'" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="INITIALISATION">
<org.eventb.core.action name="_BIjYUKxtEeiUDoNOpRQlQA" org.eventb.core.assignment="usuarios ≔  ∅" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_BIjYUaxtEeiUDoNOpRQlQA" org.eventb.core.assignment="archivos ≔ ∅" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_BIjYUqxtEeiUDoNOpRQlQA" org.eventb.core.assignment="fsist ≔  ∅" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.variable name="_s_qXcKxsEeiUDoNOpRQlQA" org.eventb.core.comment="el sistema de archivos" org.eventb.core.identifier="fsist"/>
<org.eventb.core.variable name="_s_q-gKxsEeiUDoNOpRQlQA" org.eventb.core.identifier="usuarios"/>
<org.eventb.core.variable name="_s_rlkKxsEeiUDoNOpRQlQA" org.eventb.core.identifier="archivos"/>
<org.eventb.core.invariant name="_s_rlkaxsEeiUDoNOpRQlQA" org.eventb.core.label="inv1" org.eventb.core.predicate="usuarios ⊆ USRS"/>
<org.eventb.core.invariant name="_s_sMoKxsEeiUDoNOpRQlQA" org.eventb.core.label="inv2" org.eventb.core.predicate="archivos ⊆  ARCH"/>
<org.eventb.core.invariant name="_s_sMoaxsEeiUDoNOpRQlQA" org.eventb.core.comment="Incluir invariante @inv4&#10;     En el modelo se especifica que cada archivo tiene una unica relacion de usuarios con permisos, de modo que para cada uno de&#10;     los archivos se tiene una tabla donde se relacionan cada usuario con los permisos que tiene. por ejemplo&#10;     {(archivo1 -&gt; {(juanito-&gt; leer),(juanito-&gt;escribir),(juanito-&gt;borrar),(juanito-&gt;ejecutar),(pepito-&gt;escribir)}} " org.eventb.core.label="inv3" org.eventb.core.predicate="fsist ∈ archivos → (usuarios ↔ PERM)"/>
<org.eventb.core.invariant name="_s_szsKxsEeiUDoNOpRQlQA" org.eventb.core.comment="la invariante dice que para todos los archivos debe existir almenos un&#10;     usuario que tenga todos los permisos de PERM.&#10;     Integrantes Nicolas Ortiz y Ivan Valderrama&#10;     Requerimiento de prueba:&#10;     - Quitar/inv4[∃ u .u∈dom(a0) ∧ a0[{u}]=PERM]:  Pide que pruebe que despues de quitar un permiso se cumple la invariante que&#10;     siga habiendo un usuario con todos los permisos. Es una prueba inmediata debido a que esta explicito en la guarda (grd4).&#10;     - Otorgar/inv4[∃ u ·u∈dom(a0) ∧ a0[{u}]=PERM]: Pide que pruebe que despues de otorgar un permiso se cumple la invariante que&#10;     siga habiendo un usuario con todos los permisos. Es una prueba inmediata debido a que se esta agregando un permiso, no quitando.&#10;     - Crear/inv4[∃ u ·u∈dom(a0) ∧ a0[{u}]=PERM]: Pide que pruebe que el archivo nuevo que va a crear cumple la condicion de la invariante 4.&#10;     Es inmediato debido a que el evento le agrega inicialemnte al alchivo a cada uno de sus creadores todos los permisos del archivo.&#10;     -Quitar/inv3[￼&#9;fsist{a ↦ fsist(a) ∖ ({u} × prs)}∈archivos → (usuarios ↔ PERM)]: Pide que pruebe que al elmiminar los permisos del usuario sigue perteneciendo a fsist, lo cual es inmediato por las guardas. " org.eventb.core.label="inv4" org.eventb.core.predicate="∀a · a∈ran(fsist) ⇒ (∃u·u∈dom(a) ∧ a[{u}] = PERM)"/>
<org.eventb.core.event name="_BIl0kKxtEeiUDoNOpRQlQA" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="nuevo">
<org.eventb.core.parameter name="_BIl0kaxtEeiUDoNOpRQlQA" org.eventb.core.identifier="u"/>
<org.eventb.core.guard name="_BIl0kqxtEeiUDoNOpRQlQA" org.eventb.core.label="grd1" org.eventb.core.predicate="u ∈ USRS∖usuarios"/>
<org.eventb.core.action name="_BImboKxtEeiUDoNOpRQlQA" org.eventb.core.assignment="usuarios ≔ usuarios ∪  {u}" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_BImboaxtEeiUDoNOpRQlQA" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="crear">
<org.eventb.core.parameter name="_BImboqxtEeiUDoNOpRQlQA" org.eventb.core.identifier="a"/>
<org.eventb.core.parameter name="_BInCsKxtEeiUDoNOpRQlQA" org.eventb.core.identifier="gente"/>
<org.eventb.core.guard name="_BInCsaxtEeiUDoNOpRQlQA" org.eventb.core.label="grd1" org.eventb.core.predicate="a ∈ ARCH∖archivos"/>
<org.eventb.core.guard name="_BInCsqxtEeiUDoNOpRQlQA" org.eventb.core.label="grd2" org.eventb.core.predicate="gente ⊆  usuarios"/>
<org.eventb.core.guard name="_BInpwKxtEeiUDoNOpRQlQA" org.eventb.core.label="grd3" org.eventb.core.predicate="gente ≠ ∅"/>
<org.eventb.core.action name="_BIoQ0KxtEeiUDoNOpRQlQA" org.eventb.core.assignment="archivos ≔ archivos  ∪  {a}" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_BIoQ0axtEeiUDoNOpRQlQA" org.eventb.core.assignment="fsist(a) ≔ gente × PERM" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_BIoQ0qxtEeiUDoNOpRQlQA" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="otorgar">
<org.eventb.core.parameter name="_BIo34KxtEeiUDoNOpRQlQA" org.eventb.core.identifier="p"/>
<org.eventb.core.parameter name="_BIo34axtEeiUDoNOpRQlQA" org.eventb.core.identifier="u"/>
<org.eventb.core.parameter name="_BIpe8KxtEeiUDoNOpRQlQA" org.eventb.core.identifier="a"/>
<org.eventb.core.guard name="_BIpe8axtEeiUDoNOpRQlQA" org.eventb.core.label="grd1" org.eventb.core.predicate="p ∈ PERM"/>
<org.eventb.core.guard name="_BIpe8qxtEeiUDoNOpRQlQA" org.eventb.core.label="grd2" org.eventb.core.predicate="u ∈ usuarios"/>
<org.eventb.core.guard name="_BIqGAKxtEeiUDoNOpRQlQA" org.eventb.core.label="grd3" org.eventb.core.predicate="a ∈ archivos"/>
<org.eventb.core.guard name="_BIqtEKxtEeiUDoNOpRQlQA" org.eventb.core.label="grd4" org.eventb.core.predicate="u↦p ∉ fsist(a)"/>
<org.eventb.core.action name="_BIqtEaxtEeiUDoNOpRQlQA" org.eventb.core.assignment="fsist(a) ≔ fsist(a) ∪ {u↦p}" org.eventb.core.label="act1"/>
</org.eventb.core.event>
<org.eventb.core.event name="_BIrUIKxtEeiUDoNOpRQlQA" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="quitar">
<org.eventb.core.parameter name="_BIrUIaxtEeiUDoNOpRQlQA" org.eventb.core.identifier="prs"/>
<org.eventb.core.parameter name="_BIrUIqxtEeiUDoNOpRQlQA" org.eventb.core.identifier="u"/>
<org.eventb.core.parameter name="_BIr7MKxtEeiUDoNOpRQlQA" org.eventb.core.identifier="a"/>
<org.eventb.core.guard name="_BIr7MaxtEeiUDoNOpRQlQA" org.eventb.core.label="grd0" org.eventb.core.predicate="a ∈ archivos"/>
<org.eventb.core.guard name="_BIsiQKxtEeiUDoNOpRQlQA" org.eventb.core.label="grd1" org.eventb.core.predicate="u ∈ dom(fsist(a))"/>
<org.eventb.core.guard name="_BIsiQaxtEeiUDoNOpRQlQA" org.eventb.core.comment="{u} x prs ⊆ fsist(a)" org.eventb.core.label="grd2" org.eventb.core.predicate="prs ⊆ fsist(a)[{u}]"/>
<org.eventb.core.guard name="_BItJUKxtEeiUDoNOpRQlQA" org.eventb.core.label="grd3" org.eventb.core.predicate="prs≠∅"/>
<org.eventb.core.guard name="_BItJUaxtEeiUDoNOpRQlQA" org.eventb.core.comment="∃x· x∈dom(fsist(a)∧ x ≠ u ∧ fsist(a)[{otro}] = PERM&#10;Se garantiza que la persona a la&#10;         que se le van a restringir los permisos no sea la unica  persona que tenga todos los permisos " org.eventb.core.label="grd4" org.eventb.core.predicate="(fsist(a)[{u}]=PERM) ⇒ (∃x· x∈dom(fsist(a)) ∧(fsist(a)[{x}]=PERM) ∧ x≠u)"/>
<org.eventb.core.action name="_BItwYKxtEeiUDoNOpRQlQA" org.eventb.core.assignment="fsist(a) ≔ fsist(a)∖ ({u}×prs)" org.eventb.core.comment="Se sustrae a la tabla del archivo a las parejas que tengan de usuario u." org.eventb.core.label="act1"/>
</org.eventb.core.event>
</org.eventb.core.machineFile>
